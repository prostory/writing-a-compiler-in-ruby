# 为main函数创建一个简单的prolog/epilog

### 背景介绍和一小部分代码

通常情况下，当我编写一个实验性质的编译器时，我会自顶向下的开始。换句话说，无论是手动编写还是使用一个解析器生成器，首先我会按照传统的做法来设计一个解析器。然后，我会开始编写各种树转换代码将AST（[抽象语法树]）转换成符号表，做错误检测，为抽象语法树添加各种信息，并最终生成代码。在我切换到Linux后，我经常会“临阵脱逃”并将代码编译成C。如果你的语言和C语言的语义（它往往会给出低层次的C语义）非常匹配，这样也是ok的。

我的第一个编译器是使用M68000汇编语言编写的，最终生成M68000汇编器。我通过允许内联汇编语言的方式来[引导启动]它，并逐步为其添加结构。首先，我会添加函数和函数调用，并且开始使用它们来构我的编译器。然后，我会添加能够在汇编寄存器上运行的基本算法。然后我会添加本地变量等等，但其中也会穿插汇编的解析，这样寄存器分配器可以保持寄存器在汇编器中使用的清晰性。逐渐的，这个编译器从M68000演变成我的混合语言，并且其中的汇编语言越来越少。

我想要再开始写一个编译器。尽管我这次不打算用汇编语言来编写，但我会从编译器的底部——代码生成器开始。并且，我会遵循以下这些目标：
* 简单性永远凌驾于性能之上。编译器要达成的目标是可以被重写在它的目标语言中来运行——换句话说，我想要它可以自举。初始代码将会被扔掉，因为它会比实际所需浪费更多时间来做更多的工作。我们可以以后再来做性能优化。
* 不做约束性能的决定。尽管性能本身不是一个目标，但是不应轻易的做那些会永远毁灭这个语言的低性能，或者是那些以后需要花大量的时间来修复的事情。Ruby，我正注视着你（=> 编写关于Ruby的运行时活力）。
* 简单性永远凌驾于方便之上。不要仅仅为了方便而添加功能——只有当他们有助于引导时才添加功能。这意味着它们必须使其更简单，而不是增加复杂性而增大编译器转换到目标语言的难度。
* 延迟设计语言的功能。首先，我想要一个有能力的并且高度灵活的代码生成器，支持AST来允许编码一整套非常不同的功能，或者使它可以很容易的添加一整套不同的功能。因此，我看中了在LISP/Scheme和Smalltalk中的低级别功能（概念，没有具体的细节）的表现力，和目标为类似于Ruby语言中的语法，元编程能力和对象模型。

我不想去学习x86汇编语言，然而我想要以x86为目标平台。这有点夸大其词。我精通M68K汇编语言和6510汇编语言，并且我足够了解x86汇编语言的比特和片段，可以很好的阅读它的代码。但我以前从未在编写的任何重要的代码中使用过它，并且我也不打算开始使用。我所知道的大量的信息都是来自于查看gcc输出的汇编代码。“gcc -S”是你的朋友。我的汇编语言的知识总体上已经足够对于接下来需要做的有一个较好的理解，即使我不知道x86汇编语言的具体情况。我可能会犯愚蠢的错误，但愿我可以从其中（和任何一个足够愚蠢地相信我对 x86 如何更好地得到他们的头检查最初的想法——我在这里的学习到了）学到更多。听起来像有很多捷径还有很多痛苦，不是吗？但它会很有趣！所以，让我们以最小程度的无用代码开始：
```ruby
    #!/bin/env ruby
    
    class Compiler
    
      def compile(exp)
        # Taken from gcc -S output
        puts <<PROLOG
        .file   "bootstrap.rb"
        .text
    .globl main
        .type   main, @function
    main:
        leal    4(%esp), %ecx
        andl    $-16, %esp
        pushl   -4(%ecx)
        pushl   %ebp
        movl    %esp, %ebp
        pushl   %ecx
    PROLOG
    
        puts <<EPILOG
        popl    %ecx
        popl    %ebp
        leal    -4(%ecx), %esp
        ret
    EPILOG
    
        puts <<GLOBAL_EPILOG
        .size   main, .-main
    GLOBAL_EPILOG
      end
    end
    
    prog = [:puts,"Hello World"]
    
    Compiler.new.compile(prog)
```
它没有做任何事。真的，它只是用gcc -S编译如下代码的结果而已:
```c
int main()
{}
```
......，摔成了碎片。它是一个完全工作的编译器......有点...不幸的是，它把任何输入都编译成了空操作，所以它是完全无用的。但让我们开始婴儿学步。考虑到本系列文章的“意识流”。我做这个只是为了好玩。我不想坐在那里做一个清晰漂亮的前期设计。我也不羞于改变我头脑中的想法而扯出代码，或把以前扯出的代码再改回去。

你在这里看到的代码是经过二次修改的：我做的每次SVN提交都有为我的帖子添加备注，但这些帖子包含大量额外的解释。有时，这些解释使我改变了关于这些事情的想法，但我不会做出重大改变，除非我认为它会使解释更清晰或者我第一次所做的修改有明显的错误。即使后来我可能把它放下了，有一个备注，我在以后也可以自己修复它。有时我会压缩一些花了一段时间来做的步骤，但那些都是些微不足道的“事后”的解释罢了。

[抽象语法树]: http://en.wikipedia.org/wiki/Abstract_syntax_tree
[引导启动]: http://en.wikipedia.org/wiki/Bootstrapping_(compilers)